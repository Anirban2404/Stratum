/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Thu May 04 2017 14:23:23 GMT-0500 (CDT).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */



define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'common/util/ejs',
    'events'
], function (PluginConfig,
             pluginMetadata,
             PluginBase,
             ejs,
             Emitter) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of codeGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin codeGenerator.
     * @constructor
     */
    var nngenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.pathToNode = {};

    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    nngenerator.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    nngenerator.prototype = Object.create(PluginBase.prototype);
    nngenerator.prototype.constructor = nngenerator;
    var deasync = require("deasync")
    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    nngenerator.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject,
            codeTemplate;
        self.extractDataModel();

    };


    nngenerator.prototype.extractDataModel = (function (callback) {
        var self = this;
        var visited1 = false;
        // // In order to avoid multiple iterative asynchronous 'load' calls we pre-load all the nodes in the state-machine
        // // and builds up a local hash-map from their paths to the node.
        return this.core.loadSubTree(self.activeNode)
            .then(function (nodes) {
                // All the nodes or objects
                var childNode,
                    childName,
                    childrenPaths;

                for (var i = 0; i < nodes.length; i += 1) {
                    self.pathToNode[self.core.getPath(nodes[i])] = nodes[i];
                    // self.logger.info(self.core.getAttribute(nodes[i], 'name'));
                }

                childrenPaths = self.core.getChildrenPaths(self.activeNode);

                var editors_input = [];
                var editors_dp = [];
                var editors_ml = [];
                var editors_eval = [];
                var ip_items = 0;
                var dp_items = 0;
                var ml_items = 0;
                var eval_items = 0;
                var viz_items = 0;
                for (var i = 0; i < childrenPaths.length; i += 1) {
                    childNode = self.pathToNode[childrenPaths[i]];
                    // Log the name of the child (it's an attribute so we use getAttribute).
                    childName = self.core.getAttribute(childNode, 'name');

                    self.logger.info('At childNode', childName);
                    // if (self.isMetaTypeOf(childNode, self.META['Input']) === true) {
                    //     childName = self.core.getAttribute(childNode, 'path');
                    //     self.logger.info('At childNode', childName);
                    // }

                    if (self.isMetaTypeOf(childNode, self.META['Input']) === true) {

                        var inNode = self.core.getChildrenPaths(childNode);
                        for (var j = 0; j < inNode.length; j += 1) {

                            self.logger.info(self.core.getAttribute(self.pathToNode[inNode[j]], 'name'));
                            self.logger.info(self.core.getAttribute(self.pathToNode[inNode[j]], 'codeEditor'));
                            var _func = self.core.getAttribute(self.pathToNode[inNode[j]], 'codeEditor');
                            editors_input[ip_items] = _func;
                            // self.logger.error('Arrayitem', items);
                            ip_items++;

                        }
                    }

                    if (self.isMetaTypeOf(childNode, self.META['DataPreprocessing']) === true) {
                        var acqNode = self.core.getChildrenPaths(childNode);
                        var srcName, dstName;
                        for (var j = 0; j < acqNode.length; j += 1) {
                            self.logger.info(self.core.getAttribute(self.pathToNode[acqNode[j]], 'name'));

                            if ((self.isMetaTypeOf(self.pathToNode[acqNode[j]], self.META['Connections'])) === true) {

                                // Should be ordered
                                var evalName = self.core.getAttribute(self.pathToNode[acqNode[j]], 'name');
                                self.logger.info('At childNode', evalName);
                                var src_Path = self.core.getPointerPath(self.pathToNode[acqNode[j]], 'src');
                                var dst_Path = self.core.getPointerPath(self.pathToNode[acqNode[j]], 'dst');
                                if (src_Path && dst_Path) {
                                    var srcNode = self.pathToNode[src_Path];
                                    var dstNode = self.pathToNode[dst_Path];
                                    srcName = self.core.getAttribute(srcNode, 'name');
                                    dstName = self.core.getAttribute(srcNode, 'name');
                                    self.logger.info(self.core.getAttribute(srcNode, 'codeEditor'));
                                    var _func1 = self.core.getAttribute(srcNode, 'codeEditor');
                                    editors_dp[dp_items] = _func1;
                                    self.logger.error('Arrayitem', dp_items);
                                    dp_items++;
                                    var _func2 = self.core.getAttribute(dstNode, 'codeEditor');
                                    editors_dp[dp_items] = _func2;
                                    self.logger.error('Arrayitem', dp_items);
                                    dp_items++;
                                }

                            }
                            else {
                                var name = self.core.getAttribute(self.pathToNode[acqNode[j]], 'name');
                                if (name != srcName || name != dstName) {
                                    self.logger.info(self.core.getAttribute(self.pathToNode[acqNode[j]], 'codeEditor'));
                                    var _func1 = self.core.getAttribute(self.pathToNode[acqNode[j]], 'codeEditor');
                                    editors_dp[dp_items] = _func1;
                                    self.logger.error('Arrayitem', dp_items);
                                    dp_items++;
                                }
                            }
                        }
                    }

                    if (self.isMetaTypeOf(childNode, self.META['MLAlgorithms']) === true) {
                        var mlNode = self.core.getChildrenPaths(childNode);
                        var srcNames = [];
                        var dstNames = [];
                        for (var j = 0; j < mlNode.length; j += 1) {
                            self.logger.info(self.core.getAttribute(self.pathToNode[mlNode[j]], 'name'));
                            if ((self.isMetaTypeOf(self.pathToNode[mlNode[j]], self.META['Connections'])) === true) {

                                // Should be ordered
                                var mlName = self.core.getAttribute(self.pathToNode[mlNode[j]], 'name');
                                self.logger.info('At childNode', mlName);
                                var src_Path = self.core.getPointerPath(self.pathToNode[mlNode[j]], 'src');
                                var dst_Path = self.core.getPointerPath(self.pathToNode[mlNode[j]], 'dst');
                                if (src_Path && dst_Path) {
                                    var srcNode = self.pathToNode[src_Path];
                                    var dstNode = self.pathToNode[dst_Path];
                                    var srcName = self.core.getAttribute(srcNode, 'name');
                                    var dstName = self.core.getAttribute(dstNode, 'name');
                                    srcNames.push(srcName);
                                    dstNames.push(dstName);
                                    //self.logger.info(self.core.getAttribute(srcNode, 'codeEditor'));
                                    var _func1 = self.core.getAttribute(srcNode, 'codeEditor');
                                    editors_ml[ml_items] = _func1;
                                    //self.logger.error('Arrayitem', ml_items);
                                    ml_items++;
                                    var _func2 = self.core.getAttribute(dstNode, 'codeEditor');
                                    editors_ml[ml_items] = _func2;
                                    //self.logger.error('Arrayitem', ml_items);
                                    ml_items++;
                                }
                            }
                        }

                        self.logger.info("*s***",srcNames);
                        self.logger.info("*d***",dstNames);

                        for (var j = 0; j < mlNode.length; j += 1) {
                            var name = self.core.getAttribute(self.pathToNode[mlNode[j]], 'name');
                            self.logger.info(name);
                            self.logger.info("sname",srcNames.indexOf(name));
                            self.logger.info("dname",dstNames.indexOf(name));
                            if ((srcNames.indexOf(name) === -1) && (dstNames.indexOf(name) === -1)) {
                                self.logger.info ("??",name);
                                var _func = self.core.getAttribute(self.pathToNode[mlNode[j]], 'codeEditor');
                                editors_ml[ml_items] = _func;
                                // self.logger.error('Arrayitem', items);
                                ml_items++;
                            }
                        }

                    }

                    if (self.isMetaTypeOf(childNode, self.META['EvaluateModel']) === true) {
                        var evalNode = self.core.getChildrenPaths(childNode);
                        for (var j = 0; j < evalNode.length; j += 1) {

                            self.logger.info(self.core.getAttribute(self.pathToNode[evalNode[j]], 'name'));
                            self.logger.info(self.core.getAttribute(self.pathToNode[evalNode[j]], 'codeEditor'));
                            var _func = self.core.getAttribute(self.pathToNode[evalNode[j]], 'codeEditor');
                            editors_eval[eval_items] = _func;
                            // self.logger.error('Arrayitem', items);
                            eval_items++;
                        }
                    }

                    if (self.isMetaTypeOf(childNode, self.META['Visualize']) === true) {
                        var evalNode = self.core.getChildrenPaths(childNode);
                        for (var j = 0; j < evalNode.length; j += 1) {

                            self.logger.info(self.core.getAttribute(self.pathToNode[evalNode[j]], 'name'));
                            self.logger.info(self.core.getAttribute(self.pathToNode[evalNode[j]], 'codeEditor'));
                            var _func = self.core.getAttribute(self.pathToNode[evalNode[j]], 'codeEditor');
                            editors_viz[viz_items] = _func;
                            // self.logger.error('Arrayitem', items);
                            eval_items++;
                        }
                    }
                }


                // editors_input = [];
                // editors_dp = [];
                // editors_ml = [];
                // editors_eval = [];
                var editors = []
                editors_input.forEach(function (item1, index, array) {
                    self.logger.error('editors_input', item1);
                    editors.push(item1);
                });
                editors_dp.forEach(function (item2, index, array) {
                    self.logger.error('editors_dp', item2);
                    editors.push(item2);
                });
                editors_ml.forEach(function (item3, index, array) {
                    //self.logger.error('Array', item);
                    editors.push(item3);
                });
                editors_eval.forEach(function (item4, index, array) {
                    //self.logger.error('Array', item);
                    editors.push(item4);
                });
                //editors[1] = "";
                editors.forEach(function (itemall, index, array) {
                    console.log('Array', index, itemall);
                });

                var fs = require('fs');


                fs.exists('./src/plugins/codeGenerator/templates/temp.ejs', function (exists) {
                    if (exists) {
                        //         //Show in green
                        //         // console.log('File exists. Deleting now ...');
                        //         // fs.unlink('./src/plugins/codeGenerator/templates/temp.ejs');
                        for (var iter = 0; iter < editors.length; iter++) {
                            // console.log(iter);
                            //             //Read the template file
                            var template = fs.readFileSync('./src/plugins/codeGenerator/templates/jupyter.ejs', 'utf8');
                            //console.log(template);
                            //             // var template = fs.readFile('./src/plugins/codeGenerator/templates/jupyter.ejs', 'utf8',  function read(err, data) {
                            //             //      if (err) {
                            //             //          throw err;
                            //             //      }
                            var tempcontent = template;
                            //
                            //             // Length of editor
                            // console.log(editors.length);
                            //             // Invoke the next step here however you like
                            //console.log(tempcontent);   // Put all of the code here (not the best solution)
                            tempcontent = tempcontent.replace(/<<numbers>>/g, iter + 1);
                            // console.log(tempcontent);
                            //console.log(iter);
                            // self.logger.error(editors[iter]);
                            var temed = editors[iter];
                            temed = JSON.stringify(temed);

                            // self.logger.error(temed);
                            tempcontent = tempcontent.replace(/<<source>>/g, temed);
                            // console.log(tempcontent);

                            if (iter == 0) {
                                fs.writeFile("./src/plugins/codeGenerator/templates/temp.ejs", tempcontent, function (err) {
                                    if (err) {
                                        return console.log(err);
                                    }

                                    console.log("The file was saved!");
                                    generateFile();
                                });
                            }
                            else {
                                fs.appendFile("./src/plugins/codeGenerator/templates/temp.ejs", tempcontent, function (err) {
                                    if (err) {
                                        return console.log(err);
                                    }

                                    console.log("The file was saved!");
                                    generateFile();
                                });
                            }
                        }
                    }
                    // });
                    // }
                    //     }
                    else {
                        //         //Show in red
                        self.logger.error('File not found, so not deleting.');
                        //         // fs.writeFile("./src/plugins/codeGenerator/templates/temp.ejs", tempcontent, function (err) {
                        //         //     if (err) {
                        //         //         return console.log(err);
                        //         //     }
                        //         //
                        //         //     console.log("The file was saved!");
                        //         //     //generateFile();
                        //         // });
                        for (var iter = 0; iter < editors.length; iter++) {
                            // console.log(iter);
                            //Read the template file
                            var template = fs.readFileSync('./src/plugins/codeGenerator/templates/jupyter.ejs', 'utf8');
                            // console.log(template);
                            // var template = fs.readFileSync('./src/plugins/codeGenerator/templates/jupyter.ejs', 'utf8', function read(err, data) {
                            //     if (err) {
                            //         throw err;
                            //     }
                            var tempcontent = template;
                            //
                            //     //                 // Length of editor
                            // console.log(editors.length);
                            // Invoke the next step here however you like
                            // console.log(tempcontent);   // Put all of the code here (not the best solution)
                            tempcontent = tempcontent.replace(/<<numbers>>/g, iter + 1);
                            //                 // console.log(tempcontent);
                            // self.logger.error(editors[iter]);
                            var temed = editors[iter];
                            temed = JSON.stringify(temed);
                            // self.logger.error(temed);
                            tempcontent = tempcontent.replace(/<<source>>/g, temed);
                            // console.log(tempcontent);

                            if (iter == 0) {
                                fs.writeFileSync("./src/plugins/codeGenerator/templates/temp.ejs", tempcontent);
                                generateFile();
                                // fs.writeFile("./src/plugins/codeGenerator/templates/temp.ejs", tempcontent, function (err) {
                                //     if (err) {
                                //         return console.log(err);
                                //     }
                                //
                                //     console.log("The file was saved!");
                                //     generateFile();
                                // });
                            }
                            else {
                                fs.appendFileSync("./src/plugins/codeGenerator/templates/temp.ejs", tempcontent);
                                generateFile();
                                // fs.appendFile("./src/plugins/codeGenerator/templates/temp.ejs", tempcontent, function (err) {
                                //     if (err) {
                                //         return console.log(err);
                                //     }
                                //
                                //     console.log("The file was saved!");
                                //     generateFile();
                                // });
                            }
                            //             });
                            // }
                        }
                    }
                    //
                    //
                });


                return editors;
            });

    });


    var generateFile = deasync(function (callback) {
        //fs module to read file
        var fs = require('fs');


        fs.exists('./src/plugins/codeGenerator/abc.ipynb', function (exists) {
            if (exists) {
                //Show in green
                // console.log('File exists. Deleting now ...');
                // fs.unlink('./src/plugins/codeGenerator/abc.ipynb');
            } else {
                //Show in red
                console.log('File not found, so not deleting.');
            }
        });

        //Read the header file
        var header = fs.readFileSync('./src/plugins/codeGenerator/views/header.ejs', 'utf8');
        // var header = fs.readFile('./src/plugins/codeGenerator/views/header.ejs', 'utf8', function read(err, data) {
        //     if (err) {
        //         throw err;
        //     }
        var headercontent = header;

        // Invoke the next step here however you like
        // console.log(headercontent);   // Put all of the code here (not the best solution)
        fs.writeFileSync("src/plugins/codeGenerator/abckeras.ipynb", headercontent);
        // fs.writeFile("src/plugins/codeGenerator/abc.ipynb", headercontent, function (err) {
        //     if (err) {
        //         return console.log(err);
        //     }
        //
        //     console.log("The file was saved!");
        // });
        // });

        //this.logger.warn("Array Access");

        //Read the template file
        var template = fs.readFileSync('./src/plugins/codeGenerator/templates/temp.ejs', 'utf8');
        // var template = fs.readFile('./src/plugins/codeGenerator/templates/temp.ejs', 'utf8', function read(err, data) {
        //     if (err) {
        //         throw err;
        //     }
        var templatecontent = template;

        // Invoke the next step here however you like
        // console.log(templatecontent);   // Put all of the code here (not the best solution)
        fs.appendFileSync("src/plugins/codeGenerator/abckeras.ipynb", templatecontent);
        // fs.appendFile("src/plugins/codeGenerator/abc.ipynb", templatecontent, function (err) {
        //     if (err) {
        //         return console.log(err);
        //     }
        //
        //     console.log("The file was modified!");
        // });
        //});

        //Read the footer file
        var footer = fs.readFileSync('./src/plugins/codeGenerator/views/footer.ejs', 'utf8');
        //var footer = fs.readFile('./src/plugins/codeGenerator/views/footer.ejs', 'utf8', function read(err, data) {
        //     if (err) {
        //         throw err;
        //     }
        var footercontent = footer;

        // Invoke the next step here however you like
        // console.log(footercontent);   // Put all of the code here (not the best solution)
        fs.appendFileSync("src/plugins/codeGenerator/abckeras.ipynb", footercontent);
        // fs.appendFile("./src/plugins/codeGenerator/abc.ipynb", footercontent, function (err) {
        //     if (err) {
        //         return console.log(err);
        //     }
        //
        //     console.log("The file was finalized!");
        // });
        //});
        var replace = require("replace");
        console.log("- 1");
        fs.exists('./src/plugins/codeGenerator/abckeras.ipynb', function (exists) {
            if (exists) {
                replace({
                    regex: "undefined",
                    replacement: " ",
                    paths: ['./src/plugins/codeGenerator/abckeras.ipynb'],
                    recursive: true,
                    silent: true,
                });
                console.log("- 2");
                uploadFile();
            }
        });

    });

    var uploadFile = function (callback) {
        var fs = require('fs');
        var ssh2 = require('ssh2');

        var conn = new ssh2();
        console.log("- 3");
        conn.on(
            'connect',
            function () {
                console.log("- connected");
            }
        );

        conn.on(
            'ready',
            function () {
                console.log("- ready");

                conn.sftp(
                    function (err, sftp) {
                        if (err) {
                            console.log("Error, problem starting SFTP: %s", err);
                            process.exit(2);
                        }

                        console.log("- SFTP started");

                        // Delete if existed
                        try {
                            sftp.unlink("/home/ubuntu/dataAnalytics/webGME_iPython.ipynb", function (err) {
                                if (err) {
                                    throw new Error('something bad happened');

                                }
                                else {
                                    console.log("file unlinked");
                                }
                            });
                        }
                        catch (ex) {
                            console.log("Error, problem starting SFTP: %s", err);
                        }
                        console.log("- 4");
                        // upload file
                        var readStream = fs.createReadStream("./src/plugins/codeGenerator/abckeras.ipynb");
                        var writeStream = sftp.createWriteStream("/home/ubuntu/dataAnalytics/webGME_iPython.ipynb");

                        // what to do when transfer finishes
                        writeStream.on(
                            'close',
                            function () {
                                console.log("- file transferred");
                                sftp.end();
                                process.exit(0);
                            }
                        );
                        console.log("- 5");
                        // initiate transfer of file
                        readStream.pipe(writeStream);
                    }
                );
            }
        );

        conn.on(
            'error',
            function (err) {
                console.log("- connection error: %s", err);
                process.exit(1);
            }
        );

        conn.on(
            'end',
            function () {
                process.exit(0);
            }
        );

        conn.connect(
            {
                "host": "129.59.107.143",
                "port": 22,
                "username": "ubuntu",
                "privateKey": fs.readFileSync('/root/.ssh/id_rsa')
            }
        );
    };


    return nngenerator;
})
;
